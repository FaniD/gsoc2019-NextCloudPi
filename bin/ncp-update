#!/bin/bash

# update latest NextCloudPi code from github

{
  [ "$(id -u)" -ne 0 ] && { printf "Must be run as root. Try 'sudo $0'\n"; exit 1; }

  BRANCH="${1:-master}"
  [[ "$BRANCH" != "master" ]] && echo "INFO: updating to development branch '$BRANCH'"

  TMPDIR="$( mktemp -d /tmp/ncp-update.XXXXXX || ( echo "Failed to create temp dir. Exiting" >&2; exit 1 ) )"
  trap "cd /; rm -rf \"${TMPDIR}\"; exit 0" 0 1 2 3 15

  echo -e "Downloading updates"
  git clone --depth 20 -b "$BRANCH" -q https://github.com/nextcloud/nextcloudpi.git "$TMPDIR" || {
    echo "No internet connectivity"
    exit 1
  }

  [[ -f /.ncp-image ]] || cd "$TMPDIR"         # update locally during build

  echo -e "Performing updates"

  # Latest checkpoint is the version right before the latest cleanup of update.sh
  #latest_checkpoint="1.10.11" # Static insert now, fix later
  # Get the array of updates dir
  i=0
  while read line ; do
    updates_list[ $i ]="$line"
    (( i++ ))
  done < <( ls updates )

  # The latest checkpoint is the newer version in updates dir
  latest_checkpoint=updates_list[i-1]

  # Compare current version with latest checkpoint to see if we need backwards updates
  MAJOR=$( grep -oP "\d+\.\d+\.\d+" $latest_checkpoint | cut -d. -f1 )
  MINOR=$( grep -oP "\d+\.\d+\.\d+" $latest_checkpoint | cut -d. -f2 )
  PATCH=$( grep -oP "\d+\.\d+\.\d+" $latest_checkpoint | cut -d. -f3 )

  MAJ=$( grep -oP "\d+\.\d+\.\d+" /usr/local/etc/ncp-version | cut -d. -f1 )
  MIN=$( grep -oP "\d+\.\d+\.\d+" /usr/local/etc/ncp-version | cut -d. -f2 )
  PAT=$( grep -oP "\d+\.\d+\.\d+" /usr/local/etc/ncp-version | cut -d. -f3 )

  # If the system is beyond the latest checkpoint there is no need to get in the loop
  BACKWARDS_UPDATES=false

  if [ "$MAJOR" -gt "$MAJ" ]; then
    BACKWARDS_UPDATES=true
  elif [ "$MAJOR" -eq "$MAJ" ] && [ "$MINOR" -gt "$MIN" ]; then
    BACKWARDS_UPDATES=true
  elif [ "$MAJOR" -eq "$MAJ" ] && [ "$MINOR" -eq "$MIN" ] && [ "$PATCH" -gt "$PAT" ]; then
    BACKWARDS_UPDATES=true
  fi

  if $BACKWARDS_UPDATES ; then

    # Execute a series of updates of older versions

    # Binary search to find the right checkpoint to begin the updates
    
    starting_checkpoint=0
    len=${#updates_list[@]}
    end_of_list=$(expr $len - 1)
    
    lower_bound=0
    upper_bound=$end_of_list
    while [ $lower_bound -le $upper_bound ]; do
      x=$(expr $upper_bound + $lower_bound)
      mid=$(expr $x / 2 )

      #Compare mid's version with current version
      MAJOR=$( grep -oP "\d+\.\d+\.\d+" $updates_list[mid] | cut -d. -f1 )
      MINOR=$( grep -oP "\d+\.\d+\.\d+" $updates_list[mid] | cut -d. -f2 )
      PATCH=$( grep -oP "\d+\.\d+\.\d+" $updates_list[mid] | cut -d. -f3 )
      
      apply_update=false
      if [ "$MAJOR" -gt "$MAJ" ]; then
        apply_update=true
      elif [ "$MAJOR" -eq "$MAJ" ] && [ "$MINOR" -gt "$MIN" ]; then
        apply_update=true
      elif [ "$MAJOR" -eq "$MAJ" ] && [ "$MINOR" -eq "$MIN" ] && [ "$PATCH" -gt "$PAT" ]; then
        apply_update=true
      fi

      if $apply_update ; then 
      # Mid's version update is applicable to the current version
      # Check if the previous checkpoint (mid-1) has already been applied

        previous=$(expr $mid - 1)
        if [ "$mid" -gt 0 ] ; then
          #Compare previous's version with current version
          MAJOR_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[previous] | cut -d. -f1 )
          MINOR_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[previous] | cut -d. -f2 )
          PATCH_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[previous] | cut -d. -f3 )
      
          applied=true
          if [ "$MAJOR_" -gt "$MAJ" ]; then
            applied=false
          elif [ "$MAJOR_" -eq "$MAJ" ] && [ "$MINOR_" -gt "$MIN" ]; then
            applied=false
          elif [ "$MAJOR_" -eq "$MAJ" ] && [ "$MINOR_" -eq "$MIN" ] && [ "$PATCH_" -gt "$PAT" ]; then
            applied=false
          fi

	  # If the previous checkpoint has already been applied then mid is the beggining checkpoint for the current version
	  if $applied ; then
            starting_checkpoint=$mid
	    break
	  fi
        else
          # mid is at 0
	  starting_checkpoint=$mid
	  break
	fi
	# Continue searching
	upper_bound=$(expr $mid - 1)

      else #[ $item -gt ${arr[$mid]} ] ; then
	# Mid's version update is not applicable to the current version (has already been applied)
        # Check if the next checkpoint (mid+1) has already been applied

	next=$(expr mid + 1)
        #Compare next's version with current version
        MAJOR_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[next] | cut -d. -f1 )
        MINOR_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[next] | cut -d. -f2 )
        PATCH_=$( grep -oP "\d+\.\d+\.\d+" $updates_list[next] | cut -d. -f3 )
      
        applied=false
        if [ "$MAJOR_" -gt "$MAJ" ]; then
          applied=true
        elif [ "$MAJOR_" -eq "$MAJ" ] && [ "$MINOR_" -gt "$MIN" ]; then
          applied=true
        elif [ "$MAJOR_" -eq "$MAJ" ] && [ "$MINOR_" -eq "$MIN" ] && [ "$PATCH_" -gt "$PAT" ]; then
          applied=true
        fi

	if $applied ; then
	  # Continue searching
          lower_bound=$(expr $mid + 1)
	else
          # The next version is the starting checkpoint
	  starting_checkpoint=$next
	  break
	fi
      fi
    done

    for(( i=$starting_checkpoint; i<=$end_of_list; i++)); do
      update_file=${updates_list[i]}
      #tag_update="v${MAJ}.${MIN}.${PAT}"
      #git checkout ${tag_update}
      ./${update_file} || exit 1
    done
  else
    # Up to date system updates
    ./update.sh || exit 1
  fi

  cd "$TMPDIR"
  VER=$( git describe --always --tags | grep -oP "v\d+\.\d+\.\d+" )

  # check format
  grep -qP "v\d+\.\d+\.\d+" <<< "$VER" || { "Error: missing version"; exit 1; }

  echo "$VER" > /usr/local/etc/ncp-version
  echo "$VER" > /var/run/.ncp-latest-version

  # write changelog
  git log --graph --oneline --decorate \
    --pretty=format:"[%D] %s" --date=short | \
    grep 'tag: v' | \
    sed '/HEAD ->\|origin/s|\[.*\(tag: v[0-9]\+\.[0-9]\+\.[0-9]\+\).*\]|[\1]|' | \
    sed 's|* \[tag: |[|' > /usr/local/etc/ncp-changelog

  echo -e "NextCloudPi updated to version $VER"
  exit 0
} # force to read the whole thing into memory, as its contents might change in update.sh
